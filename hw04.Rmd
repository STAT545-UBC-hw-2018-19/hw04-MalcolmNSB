---
title: "HW04: Tidy data and joins"
output: 
  github_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data reshaping

**Problem:** You have data in one “shape” but you wish it were in another. Usually this is because the alternative shape is superior for presenting a table, making a figure, or doing aggregation and statistical analysis.

**Solution:** Reshape your data. For simple reshaping, gather() and spread() from tidyr will suffice. Do the thing that is possible / easier now that your data has a new shape.

**Prompt:** Make a tibble with one row per year and columns for life expectancy for two or more countries from gapminder. 



First we load the tidyverse package and gapminder dataframe.
```{r}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gapminder))
```

###La vie en france, ou au royaume-uni ?

Is life better in France or the United Kingdom? Let's explore the comparative trend in their life expectancies! 
```{r}
#create tibble fr_uk_lifeExp consisting of filtered gapminder data
fr_uk_lifeExp <- gapminder %>% 
  
  #capitalise year (for aesthetic purposes)
  rename(Year = year) %>% 
  
  #filter gapminder to France & United Kingdom
  filter(country == "France" | country == "United Kingdom") %>% 
  
  #select year, country, and life expectancy
  select(Year, country, lifeExp) %>% 
  
  #spread the life expectancy data by country
  spread(key = "country", value = "lifeExp")

#produce nice table
knitr::kable(fr_uk_lifeExp)
```
 
Now we take advantage of this data shape to make a plot of their life expectancies against each other.

```{r}
#plot United Kingdom life expectancy against that of France
fr_uk_lifeExp %>% 
ggplot(aes(`United Kingdom`, France)) +
  
  #make scatter plot
  geom_point() +
  
  #interpolate using smooth curve
  geom_smooth(method = loess) +
  
  #plot title
  ggtitle("Life expectancy trend of United Kingdom versus France, 1952-2007")
```

It looks like life is good in France and the United Kingdom! We'll just have to spend some time in both :) 

##Join Prompts

**Problem:** You have two data sources and you need info from both in one new data object.

**Solution:** Perform a join, which borrows terminology from the database world, specifically SQL.


###Activity #1

Create a second data frame, complementary to Gapminder. Join this with (part of) Gapminder using a dplyr join function and make some observations about the process and result. Explore the different types of joins. 

Before we begin, we make some remarks about the two data sets we will join.
        
- We shall build a second data frame of countries consisting of Canada, United Kingdom, France, and Russia. The variables will be national animal, NATO membership, and capital city. 

- We shall use a subset of the gapminder data.frame consisting of countries Canada, France, United Kingdom, and Norway, with their respective life expectancy in the year 2007.

- Note that we specifically chose Russia because it is NOT contained in the gapminder data frame. Moreover, Norway is NOT contained in our own constructed tibble, so there is overlap, but not completely.

- We also chose to include continent as a column in our constructed data frame so that their are two columns (continent and country) which are the same in both data frames.


```{r}
#Creating our own tibble

#column of chosen countries
countries <- c("Canada", "United Kingdom", "France", "Russia")

#column of continents corresponding to chosen countries
continent<- c("Americas", "Europe", "Europe", "Asia") 

#column of national animal of corresponding country
Anim <- c("Beaver", "Lion", "Gallic Rooster", "Bear") 

#column of NATO membership
NATO <- c("Yes", "Yes", "Yes", "No") 

#column of Capital city
Cap <- c("Ottawa", "London", "Paris", "Moscow") 

#create the tibble `addinfo` consisting of all the above columns
addinfo <- tibble(continent = continent, country = countries,  
                  `national animal` = Anim, `NATO membership` = NATO, `capital city` = Cap)


#make table of output'
knitr::kable(addinfo)
```

This table is the `addinfo` data frame.

Now we create the filtered gapminder data frame.

```{r}
#filter gapminder dataset to year 2007, 
#and the countries in the countries column created earlier,
#but include Norway
gaptemp <- gapminder %>% 
  filter(year == 2007, country%in%countries | country == "Norway") %>% 
  
  #select subset of data in 2007 (for simplicity)
  select(continent, country, lifeExp)

 
#the continent and country columns in gapminder are of `factor` type; 
#change them to `character` to match our constructed tibble above
gapfilt <- transmute(gaptemp, continent = as.character(continent), 
                     country = as.character(country), lifeExp)

knitr::kable(gapfilt)
```

Table: Life expectancy in 2007.

Now let's investigate the various join functions. The two data frames have two columns in common: continent, and country. Let's see  first what happens when we (left) join by country only.

```{r}
#left join by country
left_join(gapfilt, addinfo, by = "country") %>% 
  knitr::kable()
```


The left join by country looks for countries in `addinfo` that match with `gapfilt` , and if found, the rows of `addinfo` are added (on the right) to `gapfilt`. Notice that the ordering of rows doesn't matter for matching (e.g. France is the second row in `gapfilt` but the third row in `addinfo`).

We see that left joining by country only, the common column of continent is not automatically recognised - instead they are treated as two distinct columns and automatically given ".x" and ".y" demarcations. Note as expected, Russia does not appear in the table, because it is not in `gapfilt`.

From here on, we join by continent and country (the default, unless specified otherwise).
```{r}
left_join(gapfilt, addinfo) %>% 
  knitr::kable()
```
```{r}
left_join(addinfo, gapfilt) %>% 
  knitr::kable()
```



```{r}
right_join(gapfilt, addinfo) %>% 
  knitr::kable()
```

```{r}
right_join(addinfo, gapfilt)
```

```{r}
right_join(gapfilt, addinfo) %>% 
  knitr::kable()
```

```{r}
inner_join(gapfilt, addinfo) %>% 
  knitr::kable()
```


```{r}
inner_join(addinfo, gapfilt)
```

```{r}
full_join(gapfilt, addinfo) %>% 
  knitr::kable()
```

```{r}
bind_rows(gapfilt, addinfo) %>% 
  knitr::kable()
```


```{r}
full_join(addinfo, gapfilt) %>% 
  knitr::kable()
```


```{r}
semi_join(gapfilt, addinfo) %>% 
  knitr::kable()
```

```{r}
semi_join(addinfo, gapfilt) %>% 
  knitr::kable()
```


```{r}
anti_join(gapfilt, addinfo) %>% 
  knitr::kable()
```

```{r}
anti_join(addinfo, gapfilt) %>% 
  knitr::kable()
```

```{r}
bind_cols(gapfilt, addinfo) %>% 
  knitr::kable()
```



```{r}
a <- select(gapfilt, continent, country)
b <- select(addinfo, continent, country)

knitr::kable(a)
knitr::kable(b)
```

```{r}
intersect(a,b) %>% 
  knitr::kable()
```

```{r}
union(a,b) %>% 
  knitr::kable()
```

```{r}
setdiff(a,b) %>% 
  knitr::kable()
```

```{r}
setdiff(b,a) %>% 
  knitr::kable()
```


##Exploring merge function
For simplicity we work with the following tibbles

```{r}
(a <- tibble(x1 = LETTERS[1:3], x2 = 1:3))
(b <- tibble(x1 = LETTERS[c(1,2)], x3 = c("T", "F")))
```
```{r}
merge(a,b)
left_join(a,b)
right_join(a,b)
merge(b,a)
merge(a,b, by = "x1")
```
```{r}
match(a,b)
match(b,a)
```



